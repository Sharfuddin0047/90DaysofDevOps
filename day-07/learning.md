# üêß Day 07 ‚Äì Linux File System Hierarchy & Scenario-Based Practice

This note focuses on understanding where important files live in Linux and practicing real-world troubleshooting scenarios.

---

# üìÅ Part 1: Linux File System Hierarchy

## ‚úÖ Core Directories (Must Know)

### `/` ‚Äì Root Directory
- The top-level directory; everything starts here.
- All other directories branch from root.

**Command:**
```bash
ls -l /
```
**Observed:** `bin`, `etc`, `home`, `usr`, `var`  

**I would use this when:** Navigating the entire system or locating major directories.

---

### `/home` ‚Äì User Directories
- Contains personal folders for each user.
- Stores user files, downloads, and configs.

**Command:**
```bash
ls -l /home
```
**Observed:** User folders like `ubuntu` or `user`.

**I would use this when:** Managing user data or checking disk usage.

---

### `/root` ‚Äì Root User Home
- Private home directory for the root (admin) user.
- Not accessible to normal users.

**Command:**
```bash
ls -l /root
```
**Observed:** Admin scripts and configuration files.

**I would use this when:** Performing administrative troubleshooting.

---

### `/etc` ‚Äì Configuration Files
- Stores system-wide configuration files.
- Critical for services and OS behavior.

**Command:**
```bash
ls -l /etc | head
```
**Observed:** Files like `hostname`, `hosts`, `ssh`.

**I would use this when:** Debugging service configs or updating system settings.

---

### `/var/log` ‚Äì Log Files
- Contains logs generated by the system and services.
- One of the first places to check during incidents.

**Command:**
```bash
ls -l /var/log | head
```
**Observed:** `syslog`, `auth.log`, `kern.log`.

**I would use this when:** Investigating failures or unexpected behavior.

---

### `/tmp` ‚Äì Temporary Files
- Stores short-lived files created by applications.
- Often cleared after reboot.

**Command:**
```bash
ls -l /tmp
```
**Observed:** Temporary folders and session files.

**I would use this when:** Checking temporary storage or testing file operations.

---

## ‚úÖ Additional Directories (Good to Know)

### `/bin`
- Holds essential command binaries needed for booting and basic operation.

**Command:**
```bash
ls -l /bin | head
```
**Observed:** Commands like `ls`, `cp`, `mv`.

**I would use this when:** Verifying core commands exist.

---

### `/usr/bin`
- Contains most user-level command binaries.

**Command:**
```bash
ls -l /usr/bin | head
```
**Observed:** Tools like `python`, `git`, `nano`.

**I would use this when:** Checking installed software.

---

### `/opt`
- Used for optional or third-party applications.

**Command:**
```bash
ls -l /opt
```
**Observed:** May contain custom-installed packages.

**I would use this when:** Troubleshooting manually installed apps.

---

## üîß Hands-on Tasks

### Find Largest Log Files
```bash
du -sh /var/log/* 2>/dev/null | sort -h | tail -5
```
**Observation:** Identified the largest logs to monitor disk usage.

---

### View Hostname Config
```bash
cat /etc/hostname
```
**Observation:** Confirmed system hostname.

---

### Check Home Directory
```bash
ls -la ~
```
**Observation:** Viewed hidden files like `.bashrc`.

---

# üö® Part 2: Scenario-Based Practice

---

## ‚úÖ Scenario 1: Service Not Starting

**Step 1:**  
```bash
systemctl status myapp
```
**Why:** Determines whether the service is running, failed, or inactive.

**Step 2:**  
```bash
journalctl -u myapp -n 50
```
**Why:** Checks recent logs for error messages.

**Step 3:**  
```bash
systemctl is-enabled myapp
```
**Why:** Verifies if the service starts automatically on boot.

**Step 4:**  
```bash
systemctl restart myapp
```
**Why:** Attempts recovery after identifying the issue.

---

## ‚úÖ Scenario 2: High CPU Usage

**Step 1:**  
```bash
top
```
**Why:** Shows live CPU usage and highlights heavy processes.

**Step 2:**  
```bash
ps aux --sort=-%cpu | head -10
```
**Why:** Lists top CPU-consuming processes.

**Step 3:**  
```bash
ps -p <PID> -o pid,ppid,cmd,%cpu,%mem
```
**Why:** Provides detailed information about the suspicious process.

---

## ‚úÖ Scenario 3: Finding Service Logs

**Step 1:**  
```bash
systemctl status docker
```
**Why:** Confirms the service state and shows log hints.

**Step 2:**  
```bash
journalctl -u docker -n 50
```
**Why:** Displays recent logs.

**Step 3:**  
```bash
journalctl -u docker -f
```
**Why:** Follows logs in real time for active debugging.

---

## ‚úÖ Scenario 4: File Permission Issue

**Step 1: Check permissions**
```bash
ls -l /home/user/backup.sh
```
**Why:** Identifies if execute permission is missing.

**Step 2: Add execute permission**
```bash
chmod +x /home/user/backup.sh
```
**Why:** Allows the script to run.

**Step 3: Verify changes**
```bash
ls -l /home/user/backup.sh
```
**Why:** Confirms permission update.

**Step 4: Execute script**
```bash
./backup.sh
```
**Why:** Ensures the fix worked.

---

# ‚≠ê Key Takeaways

- Knowing the Linux file system helps you find configs, logs, and binaries faster.
- Logs should always be checked before restarting services.
- A structured troubleshooting flow reduces downtime.
- Scenario practice builds real DevOps confidence.

---

‚úÖ **Final Insight:**  
Mastering filesystem navigation and troubleshooting steps prepares you for production environments and DevOps interviews.
